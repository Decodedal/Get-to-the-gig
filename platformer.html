<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Side-Scrolling Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
        }

        #gameCanvas {
            border: 3px solid #ff006e;
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.5), 0 0 10px rgba(0, 255, 0, 0.3);
            display: block;
            touch-action: none;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // ============================================
        // CONFIGURATION OBJECT - All Visual Constants
        // ============================================
        const CONFIG = {
            // Canvas
            canvas: {
                width: 800,
                height: 400
            },

            // Colors - Punk Aesthetic
            colors: {
                background: {
                    base: '#0a0a0a',        // Deep black
                    overlay: '#1a1a1a'      // Slightly lighter for pattern
                },
                ground: '#ff006e',          // Hot pink
                player: '#00ff41',          // Neon green
                playerOutline: '#000000',   // Black outline
                obstacles: {
                    cop: '#ffff00',         // Bright yellow
                    copOutline: '#000000',
                    fascist: '#ff006e',     // Hot pink
                    fascistOutline: '#000000'
                },
                ui: {
                    text: '#00ff41',        // Neon green
                    shadow: '#000000',
                    accent: '#ff006e'       // Hot pink accent
                },
                effects: {
                    scanline: 'rgba(0, 0, 0, 0.1)',
                    vignette: 'rgba(0, 0, 0, 0.7)'
                }
            },

            // Visual Effects
            effects: {
                scanlines: true,
                scanlineSpacing: 4,
                logoPattern: true,
                logoOpacity: 0.15,
                logoSize: 100  // Size of each logo tile
            },

            // Assets
            assets: {
                logoPath: '/Lostdog-logo-white.jpg' // User will replace this
            },

            // Player
            player: {
                width: 30,
                height: 40,
                x: 150, // Fixed x position (centered-ish)
                groundY: 300, // Y position when on ground
                jumpForce: -12,
                gravity: 0.6,
                maxFallSpeed: 15
            },

            // Ground
            ground: {
                y: 340,
                height: 60
            },

            // Obstacles
            obstacles: {
                cop: {
                    width: 30,
                    height: 50,
                    color: '#ffff00',
                    outline: '#000000',
                    outlineWidth: 3,
                    isPlatform: true // Can be landed on
                },
                fascist: {
                    width: 40,
                    height: 40,
                    color: '#ff006e',
                    outline: '#000000',
                    outlineWidth: 3,
                    isPlatform: true // Can be landed on
                },
                triangle: {
                    width: 40,
                    height: 40,
                    color: '#ff0000', // Bright red for danger
                    outline: '#000000',
                    outlineWidth: 3,
                    isPlatform: false // Always dangerous
                },
                spawnDistance: 250, // Minimum distance between obstacles
                maxSpawnDistance: 400, // Maximum distance for variety
                initialSpeed: 4,
                speedIncrease: 0.0005 // Speed increase per frame
            },

            // Game
            game: {
                scrollSpeed: 4,
                maxScrollSpeed: 10,
                distanceMultiplier: 0.1 // For converting frames to distance
            },

            // Audio
            audio: {
                musicPath: 'path/to/your/music.mp3', // User will replace this
                volume: 0.5
            }
        };

        // ============================================
        // GAME SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = CONFIG.canvas.width;
        canvas.height = CONFIG.canvas.height;

        // Game state
        let gameState = 'start'; // 'start', 'playing', 'gameOver'
        let animationId = null;

        // Logo image for background pattern
        const logoImage = new Image();
        logoImage.src = CONFIG.assets.logoPath;
        let logoLoaded = false;
        logoImage.onload = () => {
            logoLoaded = true;
        };
        logoImage.onerror = () => {
            console.log('Logo image not found - will use solid background');
        };

        // Audio
        const backgroundMusic = new Audio(CONFIG.audio.musicPath);
        backgroundMusic.loop = true;
        backgroundMusic.volume = CONFIG.audio.volume;

        // Player object
        const player = {
            x: CONFIG.player.x,
            y: CONFIG.player.groundY,
            width: CONFIG.player.width,
            height: CONFIG.player.height,
            velocityY: 0,
            isJumping: false,
            isOnGround: true,
            isOnPlatform: false,
            currentPlatform: null
        };

        // Game data
        let obstacles = [];
        let scrollSpeed = CONFIG.game.scrollSpeed;
        let distance = 0;
        let frameCount = 0;
        let lastObstacleX = CONFIG.canvas.width;

        // ============================================
        // OBSTACLE MANAGEMENT
        // ============================================
        function createObstacle(type, heightLevel = 0) {
            const obstacleConfig = CONFIG.obstacles[type];
            // Height levels: 0 = ground, 1 = medium, 2 = high
            const yOffset = heightLevel * 60; // Stack height for platforms

            return {
                type: type,
                x: CONFIG.canvas.width,
                y: CONFIG.ground.y - obstacleConfig.height - yOffset,
                width: obstacleConfig.width,
                height: obstacleConfig.height,
                color: obstacleConfig.color,
                isPlatform: obstacleConfig.isPlatform,
                heightLevel: heightLevel
            };
        }

        function spawnObstacle() {
            // Difficulty increases over time
            const difficultyLevel = Math.floor(distance / 50); // Increases every 50m

            // Calculate spawn probabilities based on difficulty
            let types = ['cop', 'fascist', 'triangle'];
            let weights = [30, 30, 20]; // Start with fewer triangles

            // As difficulty increases, add more triangles and complexity
            if (difficultyLevel > 2) {
                weights = [25, 25, 35]; // More triangles
            }
            if (difficultyLevel > 5) {
                weights = [20, 20, 50]; // Even more triangles
            }

            // Weighted random selection
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            let randomType = types[0];

            for (let i = 0; i < types.length; i++) {
                if (random < weights[i]) {
                    randomType = types[i];
                    break;
                }
                random -= weights[i];
            }

            // Platforms can be at different heights (but not triangles)
            let heightLevel = 0;
            if (randomType !== 'triangle' && difficultyLevel > 1) {
                // Occasionally spawn platforms at higher levels
                const heightChance = Math.random();
                if (heightChance < 0.2 && difficultyLevel > 3) {
                    heightLevel = 2; // High platform
                } else if (heightChance < 0.4) {
                    heightLevel = 1; // Medium platform
                }
            }

            obstacles.push(createObstacle(randomType, heightLevel));

            // Sometimes spawn stacked obstacles for more challenge
            if (difficultyLevel > 4 && Math.random() < 0.15) {
                const stackType = Math.random() < 0.5 ? 'cop' : 'fascist';
                obstacles.push(createObstacle(stackType, 1));
            }
        }

        function updateObstacles() {
            // Move obstacles left
            obstacles.forEach(obstacle => {
                obstacle.x -= scrollSpeed;
            });

            // Remove off-screen obstacles
            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

            // Spawn new obstacles with dynamic spacing
            const rightmostObstacle = obstacles.length > 0
                ? Math.max(...obstacles.map(o => o.x))
                : 0;

            // Variable spawn distance based on difficulty
            const difficultyLevel = Math.floor(distance / 50);
            const minDistance = Math.max(150, CONFIG.obstacles.spawnDistance - (difficultyLevel * 10));
            const maxDistance = Math.max(minDistance + 50, CONFIG.obstacles.maxSpawnDistance - (difficultyLevel * 15));
            const spawnDistance = minDistance + Math.random() * (maxDistance - minDistance);

            if (rightmostObstacle < CONFIG.canvas.width - spawnDistance) {
                spawnObstacle();
            }
        }

        // ============================================
        // PLAYER PHYSICS
        // ============================================
        function updatePlayer() {
            // Apply gravity if not on ground or platform
            if (!player.isOnGround && !player.isOnPlatform) {
                player.velocityY += CONFIG.player.gravity;

                // Cap fall speed
                if (player.velocityY > CONFIG.player.maxFallSpeed) {
                    player.velocityY = CONFIG.player.maxFallSpeed;
                }
            }

            // If on platform, check if still above it
            if (player.isOnPlatform && player.currentPlatform) {
                const platform = player.currentPlatform;
                // Check if player moved off the platform horizontally
                if (player.x + player.width < platform.x || player.x > platform.x + platform.width) {
                    player.isOnPlatform = false;
                    player.currentPlatform = null;
                    player.velocityY = 0; // Start falling
                }
            }

            // Update position
            player.y += player.velocityY;

            // Ground collision
            if (player.y >= CONFIG.player.groundY) {
                player.y = CONFIG.player.groundY;
                player.velocityY = 0;
                player.isJumping = false;
                player.isOnGround = true;
                player.isOnPlatform = false;
                player.currentPlatform = null;
            } else {
                player.isOnGround = false;
            }
        }

        function jump() {
            if ((player.isOnGround || player.isOnPlatform) && !player.isJumping) {
                player.velocityY = CONFIG.player.jumpForce;
                player.isJumping = true;
                player.isOnGround = false;
                player.isOnPlatform = false;
                player.currentPlatform = null;
            }
        }

        // ============================================
        // COLLISION DETECTION (AABB with platform support)
        // ============================================
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function checkPlatformLanding(player, platform) {
            // Check if player is falling onto the platform from above
            const wasAbove = player.y + player.height - player.velocityY <= platform.y + 5;
            const isOnTop = player.y + player.height >= platform.y &&
                           player.y + player.height <= platform.y + platform.height / 2;
            const horizontalOverlap = player.x < platform.x + platform.width &&
                                     player.x + player.width > platform.x;

            return wasAbove && isOnTop && horizontalOverlap && player.velocityY >= 0;
        }

        function checkSideCollision(player, obstacle) {
            // Check if player is hitting the sides or bottom of obstacle
            const horizontalOverlap = player.x < obstacle.x + obstacle.width &&
                                     player.x + player.width > obstacle.x;
            const verticalOverlap = player.y < obstacle.y + obstacle.height &&
                                   player.y + player.height > obstacle.y;

            if (!horizontalOverlap || !verticalOverlap) return false;

            // Determine collision side
            const fromLeft = player.x + player.width - player.velocityY <= obstacle.x + 10;
            const fromRight = player.x >= obstacle.x + obstacle.width - 10;
            const fromBottom = player.y <= obstacle.y + obstacle.height - 10;

            return fromLeft || fromRight || fromBottom;
        }

        function checkCollisions() {
            player.isOnPlatform = false;
            player.currentPlatform = null;

            for (let obstacle of obstacles) {
                // Triangles always hurt
                if (obstacle.type === 'triangle') {
                    if (checkCollision(player, obstacle)) {
                        return true; // Game over
                    }
                }
                // Platforms can be landed on
                else if (obstacle.isPlatform) {
                    if (checkPlatformLanding(player, obstacle)) {
                        // Land on platform
                        player.y = obstacle.y - player.height;
                        player.velocityY = 0;
                        player.isOnGround = false;
                        player.isOnPlatform = true;
                        player.currentPlatform = obstacle;
                        player.isJumping = false;
                    } else if (checkCollision(player, obstacle)) {
                        // Hit from side or bottom - game over
                        return true;
                    }
                }
            }
            return false;
        }

        // ============================================
        // RENDERING FUNCTIONS
        // ============================================
        function drawBackground() {
            // Solid black background
            ctx.fillStyle = CONFIG.colors.background.base;
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);

            // Draw repeating logo pattern if loaded
            if (CONFIG.effects.logoPattern && logoLoaded) {
                ctx.globalAlpha = CONFIG.effects.logoOpacity;
                const logoSize = CONFIG.effects.logoSize;

                for (let x = 0; x < CONFIG.canvas.width; x += logoSize) {
                    for (let y = 0; y < CONFIG.canvas.height; y += logoSize) {
                        ctx.drawImage(logoImage, x, y, logoSize, logoSize);
                    }
                }

                ctx.globalAlpha = 1.0;
            }

            // Scanlines effect for gritty punk aesthetic
            if (CONFIG.effects.scanlines) {
                ctx.fillStyle = CONFIG.colors.effects.scanline;
                for (let i = 0; i < CONFIG.canvas.height; i += CONFIG.effects.scanlineSpacing) {
                    ctx.fillRect(0, i, CONFIG.canvas.width, 2);
                }
            }

            // Subtle vignette effect
            const gradient = ctx.createRadialGradient(
                CONFIG.canvas.width / 2, CONFIG.canvas.height / 2, 0,
                CONFIG.canvas.width / 2, CONFIG.canvas.height / 2, CONFIG.canvas.width / 1.5
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, CONFIG.colors.effects.vignette);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
        }

        function drawGround() {
            ctx.fillStyle = CONFIG.colors.ground;
            ctx.fillRect(0, CONFIG.ground.y, CONFIG.canvas.width, CONFIG.ground.height);
        }

        function drawPlayer() {
            // Draw black outline
            ctx.fillStyle = CONFIG.colors.playerOutline;
            ctx.fillRect(player.x - 2, player.y - 2, player.width + 4, player.height + 4);

            // Draw player
            ctx.fillStyle = CONFIG.colors.player;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function drawObstacle(obstacle) {
            const obstacleConfig = CONFIG.obstacles[obstacle.type];

            if (obstacle.type === 'triangle') {
                // Draw triangle (pointing up - dangerous!)
                const centerX = obstacle.x + obstacle.width / 2;
                const topY = obstacle.y;
                const bottomY = obstacle.y + obstacle.height;
                const leftX = obstacle.x;
                const rightX = obstacle.x + obstacle.width;

                // Draw outline
                ctx.fillStyle = obstacleConfig.outline;
                ctx.beginPath();
                ctx.moveTo(centerX, topY - 3);
                ctx.lineTo(rightX + 3, bottomY + 3);
                ctx.lineTo(leftX - 3, bottomY + 3);
                ctx.closePath();
                ctx.fill();

                // Draw triangle
                ctx.fillStyle = obstacle.color;
                ctx.beginPath();
                ctx.moveTo(centerX, topY);
                ctx.lineTo(rightX, bottomY);
                ctx.lineTo(leftX, bottomY);
                ctx.closePath();
                ctx.fill();
            } else {
                // Draw rectangle/square for platforms
                // Draw black outline
                ctx.fillStyle = obstacleConfig.outline;
                const outlineWidth = obstacleConfig.outlineWidth;
                ctx.fillRect(
                    obstacle.x - outlineWidth,
                    obstacle.y - outlineWidth,
                    obstacle.width + (outlineWidth * 2),
                    obstacle.height + (outlineWidth * 2)
                );

                // Draw obstacle
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => drawObstacle(obstacle));
        }

        function drawUI() {
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'left';

            // Distance counter
            const distanceText = `Distance: ${Math.floor(distance)}m`;

            // Shadow effect
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText(distanceText, 21, 31);

            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText(distanceText, 20, 30);

            // Difficulty level indicator
            const difficultyLevel = Math.floor(distance / 50);
            const difficultyText = `Level: ${difficultyLevel}`;

            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText(difficultyText, 21, 56);

            // Color based on difficulty
            if (difficultyLevel < 3) {
                ctx.fillStyle = CONFIG.colors.ui.text; // Green - easy
            } else if (difficultyLevel < 6) {
                ctx.fillStyle = '#ffff00'; // Yellow - medium
            } else {
                ctx.fillStyle = CONFIG.colors.ui.accent; // Pink - hard
            }
            ctx.fillText(difficultyText, 20, 55);
        }

        function drawStartScreen() {
            drawBackground();
            drawGround();

            ctx.font = 'bold 40px Courier New';
            ctx.textAlign = 'center';

            // Title with glitchy outline effect
            ctx.fillStyle = CONFIG.colors.ui.accent;
            ctx.fillText('GET TO THE GIG', CONFIG.canvas.width / 2 + 3, 77);
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('GET TO THE GIG', CONFIG.canvas.width / 2 + 2, 76);
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('GET TO THE GIG', CONFIG.canvas.width / 2, 75);

            // Game instructions
            ctx.font = 'bold 16px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('Red Triangles: Always Deadly!', CONFIG.canvas.width / 2, 130);
            ctx.fillText('Yellow/Pink Platforms: Land on Top!', CONFIG.canvas.width / 2, 150);
            ctx.fillText('Difficulty increases over time...', CONFIG.canvas.width / 2, 170);

            // Instructions
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.accent;
            ctx.fillText('Press SPACE to Jump', CONFIG.canvas.width / 2 + 2, 221);
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('Press SPACE to Jump', CONFIG.canvas.width / 2 + 1, 222);
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('Press SPACE to Jump', CONFIG.canvas.width / 2, 220);

            // Start instruction
            ctx.font = 'bold 20px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.accent;
            ctx.fillText('Press SPACE to Start', CONFIG.canvas.width / 2 + 2, 271);
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('Press SPACE to Start', CONFIG.canvas.width / 2 + 1, 272);
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('Press SPACE to Start', CONFIG.canvas.width / 2, 270);

            // Mobile instruction
            ctx.font = 'bold 14px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('(or tap on mobile)', CONFIG.canvas.width / 2, 295);
        }

        function drawGameOverScreen() {
            drawBackground();
            drawGround();

            ctx.font = 'bold 40px Courier New';
            ctx.textAlign = 'center';

            // Game Over text with glitch effect
            ctx.fillStyle = CONFIG.colors.ui.accent;
            ctx.fillText('GAME OVER', CONFIG.canvas.width / 2 + 3, CONFIG.canvas.height / 2 - 47);
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('GAME OVER', CONFIG.canvas.width / 2 + 2, CONFIG.canvas.height / 2 - 48);
            ctx.fillStyle = CONFIG.colors.ui.accent;
            ctx.fillText('GAME OVER', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 50);

            // Distance
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            const distanceText = `Distance: ${Math.floor(distance)}m`;
            ctx.fillText(distanceText, CONFIG.canvas.width / 2 + 2, CONFIG.canvas.height / 2 + 2);
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText(distanceText, CONFIG.canvas.width / 2, CONFIG.canvas.height / 2);

            // Restart instruction
            ctx.font = 'bold 20px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.accent;
            ctx.fillText('Press SPACE to Restart', CONFIG.canvas.width / 2 + 2, CONFIG.canvas.height / 2 + 51);
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('Press SPACE to Restart', CONFIG.canvas.width / 2 + 1, CONFIG.canvas.height / 2 + 52);
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('Press SPACE to Restart', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 50);
        }

        function drawGame() {
            drawBackground();
            drawGround();
            drawObstacles();
            drawPlayer();
            drawUI();
        }

        // ============================================
        // GAME LOGIC
        // ============================================
        function resetGame() {
            // Reset player
            player.x = CONFIG.player.x;
            player.y = CONFIG.player.groundY;
            player.velocityY = 0;
            player.isJumping = false;
            player.isOnGround = true;
            player.isOnPlatform = false;
            player.currentPlatform = null;

            // Reset game data
            obstacles = [];
            scrollSpeed = CONFIG.game.scrollSpeed;
            distance = 0;
            frameCount = 0;
            lastObstacleX = CONFIG.canvas.width;

            // Spawn initial obstacles (start easy with platforms)
            obstacles.push(createObstacle('cop', 0));
        }

        function startGame() {
            resetGame();
            gameState = 'playing';

            // Start music
            backgroundMusic.currentTime = 0;
            backgroundMusic.play().catch(err => {
                console.log('Audio playback failed:', err);
            });
        }

        function endGame() {
            gameState = 'gameOver';

            // Stop music
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
        }

        function updateGame() {
            if (gameState !== 'playing') return;

            frameCount++;

            // Update distance
            distance += CONFIG.game.distanceMultiplier;

            // Gradually increase scroll speed
            scrollSpeed = Math.min(
                CONFIG.game.scrollSpeed + (frameCount * CONFIG.obstacles.speedIncrease),
                CONFIG.game.maxScrollSpeed
            );

            // Update game objects
            updatePlayer();
            updateObstacles();

            // Check collisions
            if (checkCollisions()) {
                endGame();
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop() {
            // Update
            if (gameState === 'playing') {
                updateGame();
            }

            // Render
            switch (gameState) {
                case 'start':
                    drawStartScreen();
                    break;
                case 'playing':
                    drawGame();
                    break;
                case 'gameOver':
                    drawGameOverScreen();
                    break;
            }

            // Continue loop
            animationId = requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        function handleInput() {
            if (gameState === 'start') {
                startGame();
            } else if (gameState === 'playing') {
                jump();
            } else if (gameState === 'gameOver') {
                startGame();
            }
        }

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handleInput();
            }
        });

        // Touch/Click input
        canvas.addEventListener('click', () => {
            handleInput();
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // ============================================
        // START THE GAME
        // ============================================
        gameLoop();
    </script>
</body>
</html>
