<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Side-Scrolling Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
        }

        #gameCanvas {
            border: 2px solid #16213e;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: block;
            touch-action: none;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // ============================================
        // CONFIGURATION OBJECT - All Visual Constants
        // ============================================
        const CONFIG = {
            // Canvas
            canvas: {
                width: 800,
                height: 400
            },

            // Colors
            colors: {
                background: {
                    top: '#0f3460',
                    bottom: '#16213e'
                },
                ground: '#e94560',
                player: '#00d9ff',
                obstacles: {
                    cop: '#ff6b6b',
                    fascist: '#8b4513'
                },
                ui: {
                    text: '#ffffff',
                    shadow: '#000000'
                }
            },

            // Player
            player: {
                width: 30,
                height: 40,
                x: 150, // Fixed x position (centered-ish)
                groundY: 300, // Y position when on ground
                jumpForce: -12,
                gravity: 0.6,
                maxFallSpeed: 15
            },

            // Ground
            ground: {
                y: 340,
                height: 60
            },

            // Obstacles
            obstacles: {
                cop: {
                    width: 30,
                    height: 50,
                    color: '#ff6b6b'
                },
                fascist: {
                    width: 40,
                    height: 40,
                    color: '#8b4513'
                },
                spawnDistance: 300, // Minimum distance between obstacles
                initialSpeed: 4,
                speedIncrease: 0.0005 // Speed increase per frame
            },

            // Game
            game: {
                scrollSpeed: 4,
                maxScrollSpeed: 10,
                distanceMultiplier: 0.1 // For converting frames to distance
            },

            // Audio
            audio: {
                musicPath: 'path/to/your/music.mp3', // User will replace this
                volume: 0.5
            }
        };

        // ============================================
        // GAME SETUP
        // ============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = CONFIG.canvas.width;
        canvas.height = CONFIG.canvas.height;

        // Game state
        let gameState = 'start'; // 'start', 'playing', 'gameOver'
        let animationId = null;

        // Audio
        const backgroundMusic = new Audio(CONFIG.audio.musicPath);
        backgroundMusic.loop = true;
        backgroundMusic.volume = CONFIG.audio.volume;

        // Player object
        const player = {
            x: CONFIG.player.x,
            y: CONFIG.player.groundY,
            width: CONFIG.player.width,
            height: CONFIG.player.height,
            velocityY: 0,
            isJumping: false,
            isOnGround: true
        };

        // Game data
        let obstacles = [];
        let scrollSpeed = CONFIG.game.scrollSpeed;
        let distance = 0;
        let frameCount = 0;
        let lastObstacleX = CONFIG.canvas.width;

        // ============================================
        // OBSTACLE MANAGEMENT
        // ============================================
        function createObstacle(type) {
            const obstacleConfig = CONFIG.obstacles[type];
            return {
                type: type,
                x: CONFIG.canvas.width,
                y: CONFIG.ground.y - obstacleConfig.height,
                width: obstacleConfig.width,
                height: obstacleConfig.height,
                color: obstacleConfig.color
            };
        }

        function spawnObstacle() {
            // Randomly choose obstacle type
            const types = ['cop', 'fascist'];
            const randomType = types[Math.floor(Math.random() * types.length)];
            obstacles.push(createObstacle(randomType));
        }

        function updateObstacles() {
            // Move obstacles left
            obstacles.forEach(obstacle => {
                obstacle.x -= scrollSpeed;
            });

            // Remove off-screen obstacles
            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

            // Spawn new obstacles
            const rightmostObstacle = obstacles.length > 0
                ? Math.max(...obstacles.map(o => o.x))
                : 0;

            if (rightmostObstacle < CONFIG.canvas.width - CONFIG.obstacles.spawnDistance) {
                spawnObstacle();
            }
        }

        // ============================================
        // PLAYER PHYSICS
        // ============================================
        function updatePlayer() {
            // Apply gravity
            if (!player.isOnGround) {
                player.velocityY += CONFIG.player.gravity;

                // Cap fall speed
                if (player.velocityY > CONFIG.player.maxFallSpeed) {
                    player.velocityY = CONFIG.player.maxFallSpeed;
                }
            }

            // Update position
            player.y += player.velocityY;

            // Ground collision
            if (player.y >= CONFIG.player.groundY) {
                player.y = CONFIG.player.groundY;
                player.velocityY = 0;
                player.isJumping = false;
                player.isOnGround = true;
            } else {
                player.isOnGround = false;
            }
        }

        function jump() {
            if (player.isOnGround && !player.isJumping) {
                player.velocityY = CONFIG.player.jumpForce;
                player.isJumping = true;
                player.isOnGround = false;
            }
        }

        // ============================================
        // COLLISION DETECTION (AABB)
        // ============================================
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function checkCollisions() {
            for (let obstacle of obstacles) {
                if (checkCollision(player, obstacle)) {
                    return true;
                }
            }
            return false;
        }

        // ============================================
        // RENDERING FUNCTIONS
        // ============================================
        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.canvas.height);
            gradient.addColorStop(0, CONFIG.colors.background.top);
            gradient.addColorStop(1, CONFIG.colors.background.bottom);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
        }

        function drawGround() {
            ctx.fillStyle = CONFIG.colors.ground;
            ctx.fillRect(0, CONFIG.ground.y, CONFIG.canvas.width, CONFIG.ground.height);
        }

        function drawPlayer() {
            ctx.fillStyle = CONFIG.colors.player;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function drawObstacle(obstacle) {
            ctx.fillStyle = obstacle.color;
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => drawObstacle(obstacle));
        }

        function drawUI() {
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'left';

            // Distance counter
            const distanceText = `Distance: ${Math.floor(distance)}m`;

            // Shadow effect
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText(distanceText, 21, 31);

            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText(distanceText, 20, 30);
        }

        function drawStartScreen() {
            drawBackground();
            drawGround();

            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.font = 'bold 40px Courier New';
            ctx.textAlign = 'center';

            // Title
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('PLATFORMER', CONFIG.canvas.width / 2 + 2, CONFIG.canvas.height / 2 - 48);
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('PLATFORMER', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 50);

            // Instructions
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('Press SPACE to Start', CONFIG.canvas.width / 2 + 2, CONFIG.canvas.height / 2 + 22);
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('Press SPACE to Start', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 20);

            // Mobile instruction
            ctx.font = 'bold 16px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('(or tap on mobile)', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 50);
        }

        function drawGameOverScreen() {
            drawBackground();
            drawGround();

            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.font = 'bold 40px Courier New';
            ctx.textAlign = 'center';

            // Game Over text
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('GAME OVER', CONFIG.canvas.width / 2 + 2, CONFIG.canvas.height / 2 - 48);
            ctx.fillStyle = '#e94560';
            ctx.fillText('GAME OVER', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 50);

            // Distance
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.text;
            const distanceText = `Distance: ${Math.floor(distance)}m`;
            ctx.fillText(distanceText, CONFIG.canvas.width / 2, CONFIG.canvas.height / 2);

            // Restart instruction
            ctx.font = 'bold 20px Courier New';
            ctx.fillStyle = CONFIG.colors.ui.shadow;
            ctx.fillText('Press SPACE to Restart', CONFIG.canvas.width / 2 + 2, CONFIG.canvas.height / 2 + 52);
            ctx.fillStyle = CONFIG.colors.ui.text;
            ctx.fillText('Press SPACE to Restart', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 50);
        }

        function drawGame() {
            drawBackground();
            drawGround();
            drawObstacles();
            drawPlayer();
            drawUI();
        }

        // ============================================
        // GAME LOGIC
        // ============================================
        function resetGame() {
            // Reset player
            player.x = CONFIG.player.x;
            player.y = CONFIG.player.groundY;
            player.velocityY = 0;
            player.isJumping = false;
            player.isOnGround = true;

            // Reset game data
            obstacles = [];
            scrollSpeed = CONFIG.game.scrollSpeed;
            distance = 0;
            frameCount = 0;
            lastObstacleX = CONFIG.canvas.width;

            // Spawn initial obstacles
            obstacles.push(createObstacle('cop'));
        }

        function startGame() {
            resetGame();
            gameState = 'playing';

            // Start music
            backgroundMusic.currentTime = 0;
            backgroundMusic.play().catch(err => {
                console.log('Audio playback failed:', err);
            });
        }

        function endGame() {
            gameState = 'gameOver';

            // Stop music
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
        }

        function updateGame() {
            if (gameState !== 'playing') return;

            frameCount++;

            // Update distance
            distance += CONFIG.game.distanceMultiplier;

            // Gradually increase scroll speed
            scrollSpeed = Math.min(
                CONFIG.game.scrollSpeed + (frameCount * CONFIG.obstacles.speedIncrease),
                CONFIG.game.maxScrollSpeed
            );

            // Update game objects
            updatePlayer();
            updateObstacles();

            // Check collisions
            if (checkCollisions()) {
                endGame();
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop() {
            // Update
            if (gameState === 'playing') {
                updateGame();
            }

            // Render
            switch (gameState) {
                case 'start':
                    drawStartScreen();
                    break;
                case 'playing':
                    drawGame();
                    break;
                case 'gameOver':
                    drawGameOverScreen();
                    break;
            }

            // Continue loop
            animationId = requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        function handleInput() {
            if (gameState === 'start') {
                startGame();
            } else if (gameState === 'playing') {
                jump();
            } else if (gameState === 'gameOver') {
                startGame();
            }
        }

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handleInput();
            }
        });

        // Touch/Click input
        canvas.addEventListener('click', () => {
            handleInput();
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        // ============================================
        // START THE GAME
        // ============================================
        gameLoop();
    </script>
</body>
</html>
